<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
<h1 id="wichtige-notizen">Wichtige Notizen</h1>
<h2 id="wichtige-elemente">Wichtige Elemente</h2>
<ul>
<li><p><a href="reference/en/cpp.html">CPP References</a></p></li>
<li><p>Hello World</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="pp">#include </span><span class="im">&lt;string&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main(){
    cout &lt;&lt; <span class="st">&quot;Hello World&quot;</span> &lt;&lt; endl;
    <span class="cf">return</span> <span class="dv">0</span>;
}</code></pre></div></li>
<li><p>Ein/Ausgabe</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> i;
cin &gt;&gt; i;
cout &lt;&lt; i;</code></pre></div></li>
<li><p>andere coole sachen</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> x{}, y{};           <span class="co">//initialisiert x und y mit 0</span></code></pre></div></li>
</ul>
<h2 id="datentypen">Datentypen</h2>
<ul>
<li>Primitive Datentypen
<ul>
<li><code>size_t</code>
<ul>
<li>positiver int</li>
</ul></li>
</ul></li>
<li>Casts
<ul>
<li>TODO</li>
</ul></li>
<li>Arrays
<ul>
<li>beim übergeben an Funktionen die Länge mit geben!</li>
<li>löschen eines elementes geht nicht</li>
<li><p>wichtige befehle</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">size_t</span> length = <span class="dv">3</span>;              <span class="co">//size</span>
<span class="dt">int</span> arr[length];                <span class="co">//stack</span>
<span class="dt">int</span>* arr = <span class="kw">new</span> <span class="dt">int</span>[length];     <span class="co">//heap</span>
<span class="co">//sonstiges</span>
cout &lt;&lt; arr[<span class="dv">2</span>];                 <span class="co">//get</span>
arr[<span class="dv">2</span>] = <span class="dv">5</span>;                     <span class="co">//set</span>
<span class="co">//iterate</span>
<span class="cf">for</span>(<span class="dt">int</span> x: arr){ ... }
<span class="cf">for</span>(<span class="dt">size_t</span> i=<span class="dv">0</span>; i&lt;<span class="kw">sizeof</span>(arr)/<span class="kw">sizeof</span>(<span class="dt">int</span>); ++i){ ... }</code></pre></div></li>
</ul></li>
<li>CPP Arrays
<ul>
<li><a href="reference/en/cpp/container/array.html">CPP References</a></li>
</ul></li>
<li>Vector
<ul>
<li><code>#include &lt;vector&gt;</code></li>
<li>Arraylist</li>
<li>Objekte die hier rein kommen sollten einen Copy Constructor haben und einen == operator</li>
<li><p>how to use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">int</span>&gt; v();            <span class="co">//stack</span>
vector&lt;<span class="dt">int</span>&gt; v{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>};       <span class="co">//stack</span>
vector&lt;<span class="dt">int</span>&gt;* v = <span class="kw">new</span> vector&lt;<span class="dt">int</span>&gt;();         <span class="co">//heap</span>
vector&lt;<span class="dt">int</span>&gt;* v = <span class="kw">new</span> vector&lt;<span class="dt">int</span>&gt;{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>};    <span class="co">//heap</span>
<span class="co">//sonstiges</span>
v.push_back(<span class="dv">3</span>);             <span class="co">//append</span>
v[<span class="dv">3</span>];                       <span class="co">//get</span>
v[<span class="dv">3</span>] = <span class="dv">2</span>;                   <span class="co">//set</span>
v.size();                   <span class="co">//size</span>
<span class="co">//iterate</span>
<span class="cf">for</span>(<span class="kw">auto</span> x: v){...}
<span class="co">//count vector elements if lambda expression returns true</span>
<span class="dt">int</span> cnt1 = count_if (v.begin(), v.end(), [](<span class="dt">int</span> k){ <span class="cf">return</span> (<span class="dv">0</span>==k%<span class="dv">2</span>);});
<span class="kw">auto</span> result1 = find_if(v.begin(), v.end(), [](<span class="dt">int</span> k){ <span class="cf">return</span> (<span class="dv">0</span>==k%<span class="dv">2</span>);});</code></pre></div></li>
<li><p><a href="reference/en/cpp/container/vector.html">CPP References</a></p></li>
</ul></li>
<li>Remove/erase
<ul>
<li><p><code>#include &lt;algorithm&gt;</code></p></li>
<li><code>remove(begin_iterator, end_iterator, object)</code>
<ul>
<li>verschiebt alle elemente die nicht == object sind nach vorne</li>
<li>löscht quasi alle die == sind</li>
</ul></li>
<li><code>remove_if(begin_iterator, end_iterator, lambda)</code>
<ul>
<li>verschiebt alle elemente wo das lambda nicht true returnt nach vorne</li>
<li>löscht quasi alle die true sind</li>
</ul></li>
<li>remove iterator
<ul>
<li><code>auto it = remove_if(begin_iterator, end_iterator, lambda)</code></li>
<li>remove und remove_if returnen einen iterator auf das erste “gelöschte” element</li>
</ul></li>
<li><code>erase(begin_iterator, end_iterator)</code>
<ul>
<li>löscht alles zwischen begin und end</li>
</ul></li>
<li><p>to use:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">double</span>&gt; v {<span class="fl">2.5</span>, <span class="fl">2.5</span>, <span class="fl">4.6</span>, <span class="fl">7.8</span>, <span class="fl">2.5</span>};

<span class="co">//remove:</span>
remove(v.begin(), v.end(), <span class="fl">2.5</span>);
<span class="co">//dann ist v danach {4.6, 7.8, 4.6, 7.8, 2.5}</span>

<span class="co">//remove if</span>
remove_if(v.begin(), v.end(), [](<span class="dt">int</span> x){ <span class="cf">return</span> x==<span class="fl">2.5</span>});
<span class="co">//dann ist v danach {4.6, 7.8, 4.6, 7.8, 2.5}</span>

<span class="co">//erase</span>
v.erase(v.begin(), v.end()<span class="dv">-2</span>);
<span class="co">//löscht alle elemente außer die letzten beiden</span>

<span class="co">//remove and erase</span>
<span class="kw">auto</span> it = remove_if(v.begin(), v.end(), [](<span class="dt">int</span> x){ <span class="cf">return</span> x==<span class="fl">2.5</span>});
<span class="co">//dann ist v danach {4.6, 7.8, 4.6, 7.8, 2.5}</span>
<span class="co">//und it zeigt auf das 3. element</span>
v.erase(it, v.end());</code></pre></div></li>
</ul></li>
<li>Set
<ul>
<li><code>#include &lt;set&gt;</code></li>
<li>Menge
<ul>
<li>es gibt keine doppelten Elemente</li>
</ul></li>
<li><p>How to use:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">set&lt;<span class="dt">int</span>&gt; s = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>};
s.insert(<span class="dv">3</span>);
s.size();</code></pre></div></li>
<li><p><a href="reference/en/cpp/container/set.html">CPP References</a></p></li>
</ul></li>
<li>Unordered Map
<ul>
<li><code>#include &lt;unordered_map&gt;</code></li>
<li>AssoziativesArray/HashMap</li>
<li><p>How to use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">unordered_map&lt;<span class="dt">long</span>,<span class="dt">long</span>&gt; map;</code></pre></div></li>
<li><p><a href="reference/en/cpp/container/unordered_map.html">CPP References</a></p></li>
</ul></li>
<li>Chrono
<ul>
<li><code>#include &lt;chrono&gt;</code></li>
<li>Für die Zeitmessung</li>
<li><code>G_classes/G26_timing.cpp</code></li>
<li><p>how to use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f(){
    this_thread::sleep_for(chrono::milliseconds(<span class="dv">2134</span>));     <span class="co">//sleep 2134 ms</span>
    this_thread::sleep_for(chrono::seconds(<span class="dv">2</span>));             <span class="co">//sleep    2 s</span>
}
<span class="kw">auto</span> t1 = chrono::high_resolution_clock::now();
f();
<span class="kw">auto</span> t2 = chrono::high_resolution_clock::now();
cout &lt;&lt; chrono::duration_cast&lt;chrono::milliseconds&gt;(t2-t1).count() &lt;&lt; <span class="st">&quot;ms&quot;</span>;</code></pre></div></li>
<li><p><a href="reference/en/cpp/chrono.html">CPP References</a></p></li>
</ul></li>
<li>Math
<ul>
<li><code>#include &lt;cmath&gt;</code></li>
</ul></li>
</ul>
<h2 id="datenstrukturen">Datenstrukturen</h2>
<ul>
<li>Structs
<ul>
<li>Klassen ohne Funktionen mit nur public members</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//normaler struct</span>
<span class="kw">struct</span> A {
    <span class="dt">double</span> n;
    <span class="dt">bool</span> m;
};
<span class="co">//struct mit standart werten</span>
<span class="kw">struct</span> B {
    <span class="dt">int</span> n;
    <span class="dt">int</span> m=<span class="dv">3</span>;
};
<span class="co">//struct, der structs enthält</span>
<span class="kw">struct</span> C {
    A a1;
    A a2;
};
<span class="dt">int</span> main(){
    A a {<span class="fl">3.14</span>, <span class="kw">true</span>};                               <span class="co">//stack mit {} ctor</span>
    A* ap = <span class="kw">new</span> A{<span class="dv">2</span>,<span class="kw">true</span>};                          <span class="co">//heap</span>
    cout &lt;&lt; a.n &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; a.m &lt;&lt; endl;              <span class="co">//&quot;3.15 1&quot;</span>
    B b;                                            <span class="co">//bei std werten gibts keinen {} ctor mehr</span>
    b.n=<span class="dv">5</span>;
    cout &lt;&lt; b.n &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; b.m &lt;&lt; endl;              <span class="co">//&quot;5 3&quot;</span>
    C c{ {<span class="dv">1</span>, <span class="kw">true</span>}, {<span class="fl">4.5</span>, <span class="kw">false</span>} };
    cout &lt;&lt; c.a1.n &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; c.a1.m &lt;&lt; endl;        <span class="co">//&quot;1 1&quot;</span>
    cout &lt;&lt; c.a2.n &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; c.a2.m &lt;&lt; endl;        <span class="co">//&quot;4.5 0&quot;</span>
    <span class="cf">return</span> <span class="dv">1</span>;
}</code></pre></div></li>
<li>Enums
<ul>
<li>TODO, war das schon alles?</li>
<li>Liste mit Konstanten</li>
<li>wird zur Compilezeit festgelegt</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">enum</span> A {a=<span class="dv">2</span>,b=<span class="dv">3</span>,c=<span class="dv">4</span>};           <span class="co">//kann man über A::a oder nur a aufrufen</span>
<span class="kw">enum</span> B {d,e,f};                 <span class="co">//man muss andere namen nehmen als in a</span>
cout &lt;&lt; d;                      <span class="co">//&quot;0&quot; standart auf 0</span>
<span class="kw">class</span> B{
    <span class="kw">enum</span> { dim = <span class="dv">4</span> };           <span class="co">//in klassen</span>
}</code></pre></div></li>
</ul>
<h2 id="funktions-pointer">Funktions Pointer</h2>
<ul>
<li><p>Type Definition</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">double</span>(*<span class="dt">func_t</span>)(<span class="dt">double</span>);
<span class="co">//func_t ist jetzt der Name für Funktionen dieses Aufbaus</span></code></pre></div></li>
<li><p>wichtige Befehle</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">func_t</span>&gt; v;                       <span class="co">//vector der diese Funktionen enthält</span>
<span class="dt">double</span> quad(<span class="dt">double</span> x){ <span class="cf">return</span> x*x }     <span class="co">//neue func_t Funktion</span>
v.push_back(quad);                      <span class="co">//Funktion zu vector hinzufügen</span>
v.push_back(&amp;quad);                     <span class="co">//das selbe</span>
v[<span class="dv">0</span>](<span class="dv">4</span>);                                <span class="co">//ausführen, liefert 16</span></code></pre></div></li>
</ul>
<h2 id="konstruktoren">Konstruktoren</h2>
<ul>
<li><p><code>Constructor mit: a(a)</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Bruch(<span class="dt">int</span> zaehler, <span class="dt">int</span> nenner): zaehler(zaehler), nenner(nenner){}</code></pre></div></li>
<li><p><code>Copy Constructor</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Bruch(<span class="at">const</span> Bruch&amp; alt): zaehler(alt.zaehler), nenner(alt.nenner){}</code></pre></div></li>
<li><p><code>Destructor</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">~Bruch(){}</code></pre></div></li>
<li><code>{} Constructor</code>
<ul>
<li><p>Stack</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Queue q = {<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>}</code></pre></div></li>
<li><p>Heap</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Queue* q = <span class="kw">new</span> Queue{<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>}</code></pre></div></li>
<li><p>Constructor:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Queue(<span class="at">const</span> initializer_list&lt;<span class="dt">int</span>&gt;&amp; liste){
    <span class="cf">for</span>(<span class="dt">int</span> x: liste){
        <span class="kw">this</span>-&gt;elemente.push_back(x);
    }
}</code></pre></div></li>
</ul></li>
</ul>
<h2 id="operatoren">Operatoren</h2>
<ul>
<li><p><a href="reference/operatoren.html">Stackoverflow</a></p></li>
<li><p><code>Operatoren: == !=</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> <span class="kw">operator</span>==(<span class="at">const</span> Queue&amp; rechts){
    <span class="cf">return</span> <span class="kw">this</span>-&gt;elemente == rechts.elemente;
}
<span class="dt">bool</span> <span class="kw">operator</span>!=(<span class="at">const</span> Queue&amp; rechts){
    <span class="cf">return</span> !(*<span class="kw">this</span>==rechts);
}</code></pre></div></li>
<li><p><code>Operatoren: *= += /= -=</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Queue&amp; opertator+=(<span class="at">const</span> Queue&amp; rechts){
    <span class="cf">for</span>(<span class="dt">int</span> i: rechts.elemente){
        <span class="kw">this</span>-&gt;elemente.push_back(i);
    }
    <span class="cf">return</span> *<span class="kw">this</span>;
}</code></pre></div></li>
<li><code>Operatoren: * + / -</code>
<ul>
<li>links ist eine copy und das return auch</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">friend</span> Queue <span class="kw">operator</span>+(Queue links, <span class="at">const</span> Queue&amp; rechts){
    links+=rechts;
    <span class="cf">return</span> links;
}
<span class="co">//oneliner</span>
<span class="kw">friend</span> Queue <span class="kw">operator</span>+(Queue links, <span class="at">const</span> Queue&amp; rechts){ <span class="cf">return</span> links+=rechts; }</code></pre></div></li>
<li><p><code>Operator: &lt;&lt;</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">friend</span> ostream&amp; <span class="kw">operator</span>&lt;&lt;(ostream&amp; os, <span class="at">const</span> Bruch&amp; b){
    os &lt;&lt; b.zaehler &lt;&lt; <span class="st">&quot;/&quot;</span> &lt;&lt; b.nenner;
    <span class="cf">return</span> os;
}</code></pre></div></li>
<li><p><code>Operator: &gt;&gt;</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">friend</span> istream&amp; <span class="kw">operator</span>&gt;&gt; (istream&amp; istr, complex&amp; a){}</code></pre></div></li>
<li><code>Operator: []</code>
<ul>
<li>you should always provide both methods</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//setter</span>
<span class="dt">value_type</span>&amp; <span class="kw">operator</span>[](<span class="dt">index_type</span> idx){     <span class="co">//index_type is for example size_t</span>
    <span class="cf">return</span> <span class="kw">this</span>-&gt;elemente[idx];
}
<span class="co">//getter</span>
<span class="at">const</span> <span class="dt">value_type</span>&amp; <span class="kw">operator</span>[](<span class="dt">index_type</span> idx) <span class="at">const</span>{
    <span class="cf">return</span> <span class="kw">this</span>-&gt;elemente[idx];
}</code></pre></div></li>
<li><code>Operator: ++a</code>
<ul>
<li>zuerst den Wert erhöhen, dann returnen</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Bruch&amp; <span class="kw">operator</span>++(){
    ++zaehler; ++nenner;
    <span class="cf">return</span> *<span class="kw">this</span>;
}</code></pre></div></li>
<li><code>Operator: a++</code>
<ul>
<li>zuerst returnen, dann den Wert erhöhen</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Bruch <span class="kw">operator</span>++(<span class="dt">int</span>){
    Bruch tmp(*<span class="kw">this</span>);
    ++zaehler; ++nenner;
    <span class="cf">return</span> tmp;
}</code></pre></div></li>
<li><p><code>Operatoren später überladen</code></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Bruch {
    <span class="kw">public</span>:
        <span class="kw">friend</span> <span class="at">const</span> Bruch&amp; <span class="kw">operator</span>+(<span class="at">const</span> Bruch&amp; links, <span class="at">const</span> Bruch&amp; rechts);
};

<span class="at">const</span> Bruch&amp; Bruch::<span class="kw">operator</span>+(<span class="at">const</span> Bruch&amp; links, <span class="at">const</span> Bruch&amp; rechts){
    ...
}</code></pre></div></li>
</ul>
<h2 id="iterator">Iterator</h2>
<ul>
<li>man kann mit <code>for(auto a: A)</code> über die Elemente iterieren</li>
<li>Beispiel in lectures/Grinnah.cpp</li>
<li><p>G23_ranged_base_for.cpp:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> D {
    <span class="co">// nested class definition inside</span>
    <span class="kw">class</span> myiterator
    {
        <span class="kw">private</span>:
            <span class="at">const</span> D &amp; d;            <span class="co">// we need to know which iterator we traverse</span>
            <span class="dt">size_t</span> index;           <span class="co">// and the position</span>
        <span class="kw">public</span>:
            myiterator(<span class="at">const</span> D &amp; _d, <span class="dt">size_t</span> _index) : d(_d), index(_index) { }
            <span class="co">// for simplicity, compare identity and indices only</span>
            <span class="dt">bool</span> <span class="kw">operator</span>!=(<span class="at">const</span> myiterator&amp; rhs) <span class="at">const</span>{
                <span class="co">//die beiden listen müssen gleich sein, aber die position anders</span>
                <span class="cf">return</span> (&amp;d==&amp;rhs.d) &amp;&amp; (index!=rhs.index);
            }
            <span class="dt">double</span> <span class="kw">operator</span>*() <span class="at">const</span> {
                <span class="cf">return</span> d.v[index];
            }
            <span class="at">const</span> myiterator&amp; <span class="kw">operator</span>++(){
                ++index;
                <span class="cf">return</span> *<span class="kw">this</span>;       <span class="co">// standard return value</span>
            }
    };
    <span class="kw">private</span>:
        vector&lt;<span class="dt">double</span>&gt; v;
    <span class="kw">public</span>:
        <span class="co">// use initializer_list from vector</span>
        D(<span class="at">const</span> initializer_list&lt;<span class="dt">double</span>&gt;&amp; l) : v(l) { }
        myiterator begin () <span class="at">const</span> { <span class="cf">return</span> myiterator(*<span class="kw">this</span>, <span class="dv">0</span>); }
        myiterator end () <span class="at">const</span>   { <span class="cf">return</span> myiterator(*<span class="kw">this</span>, v.size()); }
};</code></pre></div></li>
</ul>
<h2 id="statics">Statics</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> C {
    <span class="kw">private</span>:
        <span class="at">static</span> <span class="dt">int</span> cnt;         <span class="co">//direkte initialisierung mit &quot;=0&quot; ist nicht erlaubt</span>
    <span class="kw">public</span>:
        C() { ++cnt; }
        <span class="at">static</span> <span class="dt">int</span> get_cnt(){ <span class="cf">return</span> cnt; }
};
<span class="dt">int</span> C::cnt = <span class="dv">0</span>;                 <span class="co">//es muss außerhalb initialisiert werden</span></code></pre></div>
<h2 id="consts">Consts</h2>
<ul>
<li>rückwärts lesen!</li>
<li>das erste kann auf beiden seiten stehen</li>
<li><p>const vars</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//lets you change all</span>
<span class="dt">int</span>*                                            <span class="co">//pointer to int</span>
<span class="co">//lets you change what it points to, but not the value</span>
<span class="dt">int</span> <span class="at">const</span> *                                     <span class="co">//pointer to constant int</span>
<span class="co">//lets you change the value, but not what it points to</span>
<span class="dt">int</span> * <span class="at">const</span>                                     <span class="co">//constant pointer to int</span>
<span class="co">//lets you change nothing</span>
<span class="dt">int</span> <span class="at">const</span> * <span class="at">const</span>                               <span class="co">//constant pointer to constant int</span>
<span class="co">//das erste kann auf beiden seiten stehen</span>
<span class="at">const</span> <span class="dt">int</span> * == <span class="dt">int</span> <span class="at">const</span> *
<span class="at">const</span> <span class="dt">int</span> * <span class="at">const</span> == <span class="dt">int</span> <span class="at">const</span> * <span class="at">const</span></code></pre></div></li>
<li>const functions and referenzen
<ul>
<li><p>normal</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="at">const</span> <span class="dt">int</span> getX() {}                 <span class="co">//returnt constantes int</span>
<span class="dt">int</span> <span class="at">const</span> getX() {}                 <span class="co">//returnt constantes int</span>
<span class="dt">int</span> getX() <span class="at">const</span> {}                 <span class="co">//this wird nicht geändert</span></code></pre></div></li>
<li><p>referenz</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="at">const</span> Queue &amp; getQueue() {}         <span class="co">//returnt constantes queue</span>
Queue <span class="at">const</span> &amp; getQueue() {}         <span class="co">//returnt constantes queue</span>
Queue &amp; <span class="at">const</span> getQueue() {}         <span class="co">//ergibt keinen sinn</span>
<span class="at">const</span> <span class="dt">int</span> &amp; getX() {}               <span class="co">//returnt eine referenz zu einem const x</span>
<span class="dt">int</span> <span class="at">const</span> &amp; getX() {}               <span class="co">//returnt eine referenz zu einem const x</span>
<span class="dt">int</span> &amp; <span class="at">const</span> getX() {}               <span class="co">//ergibt keine sinn</span>
<span class="dt">int</span> &amp; getX() {}                     <span class="co">//returnt eine referenz zu x</span>
getX() = <span class="dv">4</span>;                         <span class="co">//sets x to 4</span>
<span class="dt">void</span> setX(<span class="dt">int</span>&amp; x) {}                <span class="co">//int referenz</span>
<span class="dt">int</span> y = <span class="dv">3</span>;                          <span class="co">//lvalue erzeugen</span>
setX(y);                            <span class="co">//geht</span>
setX(<span class="dv">2</span>);                            <span class="co">//geht nicht, da 2 es ein rvalue ist</span>
<span class="dt">void</span> setX(<span class="at">const</span> <span class="dt">int</span>&amp; x) {}          <span class="co">//const int referenz</span>
setX(<span class="dv">2</span>);                            <span class="co">//geht aber kp warum (vllt wird es zur compile zeit festgelegt)</span></code></pre></div></li>
<li><p>pointer</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="at">const</span> Queue * getQueue() {}         <span class="co">//cont Queue</span>
Queue <span class="at">const</span> * getQueue() {}         <span class="co">//cont Queue</span>
Queue * <span class="at">const</span> getQueue() {}         <span class="co">//cont Pointer</span>
<span class="at">const</span> <span class="dt">int</span> * getQueue() {}           <span class="co">//cont int</span>
<span class="dt">int</span> <span class="at">const</span> * getQueue() {}           <span class="co">//cont int</span>
<span class="dt">int</span> * <span class="at">const</span> getQueue() {}           <span class="co">//cont Pointer</span></code></pre></div></li>
</ul></li>
</ul>
<h2 id="vererbung">Vererbung</h2>
<ul>
<li>Einfache Vererbung
<ul>
<li>beim erstellen
<ol style="list-style-type: decimal">
<li>Zuerst wird die Basis-Klasse erstellt</li>
<li>Dann die Kind-Klasse</li>
</ol></li>
<li>beim löschen
<ol style="list-style-type: decimal">
<li>Zuerst wird die Kind-Klasse zerstört</li>
<li>Dann die Basis-Klasse</li>
</ol></li>
<li><code>A* l = new B(4);</code>
<ul>
<li>A ist der dynamische Type, da er sich ändern kann</li>
<li>B ist der statische Type, da er sich nicht ändern kann</li>
</ul></li>
<li><code>virtual</code> muss in Basis-Klasse stehen</li>
<li>private/public
<ul>
<li><code>class B: public A</code></li>
<li>wenn es private ist, kann man von außen nur auf Methoden von B zugreifen</li>
<li>bei public kann man auch die Methoden von A mit benutzen</li>
</ul></li>
<li>friend Methoden müssen eventuell doppelt geschrieben werden(?)</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> A {
    <span class="kw">protected</span>:
        <span class="dt">int</span> n;
    <span class="kw">public</span>:
        A(<span class="dt">int</span> N) : n(N) {}
        <span class="dt">void</span> f(){}                      <span class="co">//nimm immer die methode des dynamischen Types</span>
        <span class="kw">virtual</span> <span class="dt">void</span> g(){}              <span class="co">//nimm immer die methode des statischen Types</span>
        <span class="kw">virtual</span> <span class="dt">void</span> h(){}              <span class="co">//nimm immer die methode des statischen Types</span>
        <span class="kw">virtual</span> <span class="dt">void</span> i() <span class="kw">final</span> {}       <span class="co">//final methode kann nicht überschieben werden</span>
};
<span class="kw">class</span> B: <span class="kw">public</span> A {                     <span class="co">//B erbt von A</span>
    <span class="kw">public</span>:
        B(<span class="dt">int</span> N): A(N) {}
        <span class="dt">void</span> f(){}                      <span class="co">//verdeckt die methode</span>
        <span class="co">//virtual void f(){}            //für alle kinder ist es virtual, aber nicht wenn man als dynamischen Type A hat</span>
        <span class="kw">virtual</span> <span class="dt">void</span> g(){}              <span class="co">//überschreibt die methode</span>
        <span class="dt">void</span> h(){}                      <span class="co">//überschreibt die methode und ist immernoch virtual</span>
        <span class="co">//virtual void i() final {}     //geht nicht, da es final ist</span>
};
<span class="kw">class</span> C <span class="kw">final</span>: <span class="kw">public</span> A { ... };        <span class="co">//man kann nicht mehr von C Erben</span>
A a;
B b;
<span class="co">//normal</span>
a.f();              <span class="co">//gibt A::f() aus</span>
a.g();              <span class="co">//gibt A::g() aus</span>
b.f();              <span class="co">//gibt B::f() aus</span>
b.g();              <span class="co">//gibt B::g() aus</span>
<span class="co">//Dynamischer Type ist A</span>
A* ap = <span class="kw">new</span> A();
A* bp = <span class="kw">new</span> B();
ap-&gt;f();            <span class="co">//gibt A::f() aus</span>
ap-&gt;g();            <span class="co">//gibt A::g() aus</span>
bp-&gt;f();            <span class="co">//gibt A::f() aus, weil es in A nicht virtual ist</span>
bp-&gt;g();            <span class="co">//gibt B::g() aus</span>
<span class="co">//Als Referenz verhält es sich genauso wie als pointer</span>
A&amp; ar = a;
A&amp; br = b;
ar.f();             <span class="co">//gibt A::f() aus</span>
ar.g();             <span class="co">//gibt A::g() aus</span>
br.f();             <span class="co">//gibt A::f() aus, weil es in A nicht virtual ist</span>
br.g();             <span class="co">//gibt B::g() aus</span>
<span class="co">//ohne void in der vererbten</span>
ap-&gt;h();            <span class="co">//gibt A::h() aus</span>
bp-&gt;h();            <span class="co">//gibt B::h() aus, obwohl in B nicht virtual steht</span></code></pre></div></li>
<li>Abstrakte Klassen (abstract class) / Interfaces
<ul>
<li>eine Klasse, von der man keine Objekte erstellen kann</li>
<li>Interfaces gibt es nicht</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> IReport {
    <span class="kw">virtual</span> <span class="dt">void</span> CreateReport() = <span class="dv">0</span>;        <span class="co">//&quot;=0&quot; means pure virtual</span>
};
<span class="kw">class</span> Report: IReport {
    <span class="co">//muss die pure virtual methods erstellen, sonst ist es auch eine abstracte klasse</span>
    <span class="kw">virtual</span> <span class="dt">void</span> CreateReport(){ ... }
};</code></pre></div></li>
<li>Mehrfach Vererbung
<ul>
<li>Ausgefranzt
<ul>
<li>Es gibt 2 mal A</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> A {
    <span class="kw">protected</span>:
        <span class="dt">int</span> n;
    <span class="kw">public</span>:
        A(<span class="dt">int</span> N): n(N) {}
};
<span class="kw">class</span> B1: <span class="kw">public</span> A {
    <span class="kw">public</span>:
        B1(<span class="dt">int</span> N): A(N) {}
};
<span class="kw">class</span> B2: <span class="kw">public</span> A {
    <span class="kw">public</span>:
        B2(<span class="dt">int</span> N): A(N) {}
};
<span class="kw">class</span> C: <span class="kw">public</span> B1, <span class="kw">public</span> B2 {
    <span class="kw">public</span>:
        C(<span class="dt">int</span> N): B1(N<span class="dv">+1</span>), B2(N<span class="dv">+2</span>) {}
        <span class="dt">int</span> getB1N(){
            <span class="cf">return</span> B1::n;
        }
        <span class="dt">int</span> getB2N(){
            <span class="cf">return</span> B2::n;
        }
};
B1 b1;      <span class="co">//zuerst wird A erstellt, dann B1</span>
B2 b2;      <span class="co">//zuerst wird A erstellt, dann B2</span>
C c;        <span class="co">//zuerst A, B1, dann A, B2, dann C</span>
<span class="co">//beim Löschen:</span>
<span class="co">//C: zuerst C, dann B2, A, dann B1, A</span></code></pre></div></li>
<li>Geschlossen
<ul>
<li>Es gibt 1 mal A</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> A {
    <span class="kw">protected</span>:
        <span class="dt">int</span> n;
    <span class="kw">public</span>:
        A(<span class="dt">int</span> N): n(N) {}
};
<span class="kw">class</span> B1: <span class="kw">public</span> A {
    <span class="kw">public</span>:
        B1(<span class="dt">int</span> N): A(N) {}
};
<span class="kw">class</span> B2: <span class="kw">public</span> A {
    <span class="kw">public</span>:
        B2(<span class="dt">int</span> N): A(N) {}
};
<span class="kw">class</span> C: <span class="kw">public</span> B1, <span class="kw">public</span> B2 {
    <span class="kw">public</span>:
        C(<span class="dt">int</span> N): A(N), B1(N<span class="dv">+1</span>), B2(N<span class="dv">+2</span>) {}         <span class="co">//A muss vor den anderen erstellt werden</span>
        <span class="dt">int</span> getN(){
            <span class="cf">return</span> n;
        }
};
B1 b1(<span class="dv">1</span>);       <span class="co">//zuerst wird A erstellt, dann B1 (n ist 1)</span>
B2 b2(<span class="dv">1</span>);       <span class="co">//zuerst wird A erstellt, dann B2 (n ist 1)</span>
C c(<span class="dv">1</span>);         <span class="co">//zuerst A, B1, B2, dann C (n ist 3)</span>
<span class="co">//beim Löschen:</span>
<span class="co">//C: zuerst C, dann B2, B1, A</span></code></pre></div></li>
</ul></li>
</ul>
<h2 id="templates">Templates</h2>
<ul>
<li><p>Template Klassen</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> Point {
    <span class="kw">public</span>:
        <span class="kw">typedef</span> T <span class="dt">value_type</span>;           <span class="co">//type of the value</span>
        <span class="kw">typedef</span> T <span class="dt">key_type</span>;             <span class="co">//type of the key</span>
        <span class="kw">typedef</span> T <span class="dt">size_type</span>;            <span class="co">//type of the size</span>
        <span class="co">//setzt value_type auf T, damit man von außerhalb den Type erfahren kann</span>
        T x;
        T y;
};</code></pre></div></li>
<li><p>Spezialisierung</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="dt">int</span> N&gt;
<span class="kw">class</span> Point { ... };
<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> Point&lt;T, <span class="dv">3</span>&gt; { ... };
<span class="kw">template</span> &lt;<span class="dt">int</span> N&gt;
<span class="kw">class</span> Point&lt;<span class="dt">double</span>, N&gt; { ... };</code></pre></div></li>
<li><p>Einzelne Funktionen Spezialisieren</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> Bruch {
    T getGGT(){ ... }
}
<span class="kw">template</span>&lt;&gt;
<span class="dt">int</span> Bruch&lt;<span class="dt">int</span>&gt;::getGGT(){ ... }</code></pre></div></li>
<li><p>Template Funktionen</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T1, <span class="kw">typename</span> T2&gt;
<span class="dt">void</span> Rotate(T1&amp; t1, T2&amp; t2){
    T1 tmp = t1;
    t1 = t2;
    t2 = tmp;
}</code></pre></div></li>
<li><p>Template mit Werten, anstelle von Typen</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="dt">int</span> N&gt;
<span class="kw">class</span> MyVector {
    <span class="kw">enum</span> { dim = N };
    T data[dim];
    <span class="co">//einen vorgegebenen type nutzen und einen anderen</span>
    <span class="kw">template</span> &lt;<span class="kw">typename</span> S&gt;
    MyVector&amp; <span class="kw">operator</span>=(<span class="at">const</span> MyVector&lt;S,N&gt;&amp; v){ ... }
};
<span class="co">//Vector der Dimension 3</span>
MyVector&lt;<span class="dt">int</span>, <span class="dv">3</span>&gt; mv;</code></pre></div></li>
<li>Template, welches nur Typen nimmt, welche von einer bestimmten Klasse geerbt haben
<ul>
<li>eine leere Klasse machen und dann für “Getraenke” spezialisieren</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> A {}
<span class="kw">template</span>&lt;&gt;
<span class="kw">class</span> A&lt;Getraenke&gt;{
    ...
}</code></pre></div></li>
</ul>
<h2 id="lambdas">Lambdas</h2>
<ul>
<li><p>normal</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> add = [](<span class="dt">int</span> n) { <span class="cf">return</span> n<span class="dv">+4</span>; };
<span class="kw">auto</span> inc = [](<span class="dt">int</span>&amp; n) { <span class="cf">return</span> ++n; };
add(<span class="dv">4</span>);     <span class="co">//returns 8</span>
<span class="dt">int</span> x=<span class="dv">7</span>;
inc(x);     <span class="co">//increases x</span></code></pre></div></li>
<li><p>copy outer vars</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> m = <span class="dv">12</span>;
<span class="kw">auto</span> addToM = [=](<span class="dt">int</span> n) { <span class="cf">return</span> m+n; };
addToM(<span class="dv">4</span>);  <span class="co">//returnt die summe aus m und 4</span></code></pre></div></li>
<li>reference outer vars
<ul>
<li>vars können geändert werden</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> setM = [&amp;](<span class="dt">int</span> n) { m=n };
setM(<span class="dv">5</span>);    <span class="co">//setzt m auf 5</span></code></pre></div></li>
<li><p>andere syntaxe</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> pi = []() -&gt; <span class="dt">double</span> { <span class="cf">return</span> <span class="fl">3.1415926</span>; };
<span class="kw">typedef</span> <span class="dt">double</span> (*<span class="dt">polynome_t</span>)(<span class="dt">double</span> x);
<span class="dt">polynome_t</span> quad = [](<span class="dt">double</span> x) { <span class="cf">return</span> x*x; };
<span class="co">//count vector elements if lambda expression returns true</span>
<span class="dt">int</span> cnt1 = count_if (v.begin(), v.end(), [](<span class="dt">int</span> k){ <span class="cf">return</span> (<span class="dv">0</span>==k%<span class="dv">2</span>);});
<span class="kw">auto</span> result1 = find_if(v.begin(), v.end(), [](<span class="dt">int</span> k){ <span class="cf">return</span> (<span class="dv">0</span>==k%<span class="dv">2</span>);});</code></pre></div></li>
</ul>
<h2 id="smart-pointer">Smart Pointer</h2>
<ul>
<li>Unique Pointer
<ul>
<li><code>#include &lt;memory&gt;</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">C* c = <span class="kw">new</span> C(<span class="dv">4</span>)
unique_ptr&lt;C&gt; p1(c);
unique_ptr&lt;C&gt; p2;
p2 = move(p1)               <span class="co">//verschiebt das objekt von p1 nach p2</span>
p1.get()                    <span class="co">//gibt den zeiger zu dem objekt zurück</span>
*p1                         <span class="co">//gibt das objekt selber zurück</span></code></pre></div></li>
<li>Shared Pointer
<ul>
<li><code>#include &lt;memory&gt;</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">C* c = <span class="kw">new</span> C(<span class="dv">4</span>)
shared_ptr&lt;C&gt; s1(c);
shared_ptr&lt;C&gt; s2(c);
s.reset()                   <span class="co">//löscht s</span>
p1.get()                    <span class="co">//gibt den zeiger zu dem objekt zurück</span>
*p1                         <span class="co">//gibt das objekt selber zurück</span></code></pre></div></li>
</ul>
<h2 id="threads">Threads</h2>
<ul>
<li>wenn man ein programm startet, wird der main thread gestartet</li>
<li>bei mehreren kernen laufen die threads parallel ab</li>
<li>beim kompilieren <code>-pthread</code> anhängen</li>
<li>thread führt funktion aus</li>
<li><p>how to</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Work(<span class="dt">int</span> sec){
    this_thread::sleep_for(chrono::seconds(sec));
}
thread t1(Work, <span class="dv">1</span>);
thread t2(Work, <span class="dv">2</span>);
thread t3([](){ this_thread::sleep_for(chrono::seconds(<span class="dv">2</span>)); }); <span class="co">//mit lambda</span>
t2.join();              <span class="co">//wait for t2</span>
t1.join();              <span class="co">//wait for t1</span></code></pre></div></li>
<li><p>threads mit referenzen aufrufen</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Work(<span class="dt">int</span>&amp; sec){
    this_thread::sleep_for(chrono::seconds(sec));
}
thread t1(Work, ref(<span class="dv">4</span>));</code></pre></div></li>
<li>mutex / kritische regionen
<ul>
<li><code>#include &lt;condition_variable&gt;</code></li>
<li>sperrt threads vor dem zugriff auf variablen, oder ganze bereiche eines codes</li>
<li><p><a href="reference/en/cpp/thread/mutex.html">CPP References</a></p></li>
<li><p>unsichere methode</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Work(<span class="dt">int</span>* sum, mutex* mutex_sum){
    <span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;n; ++i){
        mutex_sum-&gt;lock();
        (*sum) += <span class="dv">1</span>;
        mutex_sum-&gt;unlock();
    }
}
mutex mutex_sum;                <span class="co">//erstelle einen mutex</span>
<span class="dt">int</span> x = <span class="dv">0</span>;
thread t1(Work, &amp;x, &amp;mutex_sum)</code></pre></div></li>
<li><p>sichere methode</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Work(<span class="dt">int</span>* sum, mutex* mutex_sum){
    <span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;n; ++i){
        loack_guard&lt;mutex&gt; lk(*mutex_sum);
        (*sum) += <span class="dv">1</span>;
    }
}
mutex mutex_sum;                <span class="co">//erstelle einen mutex</span>
<span class="dt">int</span> x = <span class="dv">0</span>;
thread t1(Work, &amp;x, &amp;mutex_sum)</code></pre></div></li>
<li>wait until unlock
<ul>
<li><code>mutex.try_lock()</code>
<ul>
<li>returnt false, wenn es gelocked ist</li>
<li>wenn es nicht gelocked ist, wird es gelocked und true returnt</li>
</ul></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//zählt solange hoch, bis signal geunlocked wird</span>
<span class="co">//und lockt es direkt wieder, geht aber aus der schleife raus</span>
<span class="cf">while</span> (!signal.try_lock()){
    ++cnt;
}
<span class="co">//jetzt wieder unlocken</span>
signal.unlock();</code></pre></div></li>
</ul></li>
<li>condition variablen
<ul>
<li>wartet auf ein ereignis</li>
<li>TODO</li>
</ul></li>
</ul>
</body>
</html>
